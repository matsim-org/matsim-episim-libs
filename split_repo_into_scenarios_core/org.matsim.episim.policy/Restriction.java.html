<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Restriction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MATSim Episim</a> &gt; <a href="index.source.html" class="el_package">org.matsim.episim.policy</a> &gt; <span class="el_source">Restriction.java</span></div><h1>Restriction.java</h1><pre class="source lang-java linenums">package org.matsim.episim.policy;

import com.typesafe.config.Config;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.poi.util.Beta;
import org.matsim.api.core.v01.Id;
import org.matsim.episim.model.FaceMask;
import org.matsim.facilities.ActivityFacility;

import javax.annotation.Nullable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Represent the current restrictions on an activity type.
 */
public final class Restriction {

<span class="fc" id="L20">	private static final Logger log = LogManager.getLogger(Restriction.class);</span>

	/**
	 * Percentage of activities still performed.
	 */
	@Nullable
	private Double remainingFraction;

	/**
	 * Contact intensity correction factor.
	 */
	@Nullable
	private Double ciCorrection;

	/**
	 * Maximum allowed group size of activities.
	 */
	@Nullable
	private Integer maxGroupSize;

	/**
	 * Reduced group size for activities.
	 */
	@Nullable
	private Integer reducedGroupSize;

	/**
	 * Ids of closed facilities.
	 */
	@Nullable
	private Set&lt;Id&lt;ActivityFacility&gt;&gt; closed;

	/**
	 * {@link ClosingHours} when activity is closed.
	 */
	@Nullable
	private ClosingHours closingHours;

	/**
	 * Maps mask type to percentage of persons wearing it.
	 */
<span class="fc" id="L61">	private Map&lt;FaceMask, Double&gt; maskUsage = new EnumMap&lt;&gt;(FaceMask.class);</span>

	/**
	 * Maps location-based remainingFraction to district name
	 */
	private Map&lt;String, Double&gt; locationBasedRf;

	/**
	 * Fraction of susceptible persons, performing an activity.
	 */
	@Nullable
	private Double susceptibleRf;

	/**
	 * Remaining fraction for vaccinated persons.
	 */
	@Nullable
	private Double vaccinatedRf;

	/**
	 * Stores if this restriction should be extrapolated.
	 */
<span class="fc" id="L83">	private boolean extrapolate = false;</span>

	/**
	 * Constructor.
	 */
	private Restriction(@Nullable Double remainingFraction, @Nullable Double ciCorrection, @Nullable Integer maxGroupSize, @Nullable Integer reducedGroupSize,
						@Nullable List&lt;String&gt; closed, @Nullable ClosingHours closingHours, @Nullable Map&lt;FaceMask, Double&gt; maskUsage, Map&lt;String, Double&gt; locationBasedRf,
<span class="fc" id="L90">	                    @Nullable Double susceptibleRf, @Nullable Double vaccinatedRf) {</span>

<span class="pc bpc" id="L92" title="3 of 10 branches missed.">		if (remainingFraction != null &amp;&amp; !Objects.equals(remainingFraction, ShutdownPolicy.REG_HOSPITAL) &amp;&amp; (Double.isNaN(remainingFraction) || remainingFraction &lt; 0 || remainingFraction &gt; 1))</span>
<span class="nc" id="L93">			throw new IllegalArgumentException(&quot;remainingFraction must be between 0 and 1 but is=&quot; + remainingFraction);</span>
<span class="pc bpc" id="L94" title="2 of 6 branches missed.">		if (ciCorrection != null &amp;&amp; (Double.isNaN(ciCorrection) || ciCorrection &lt; 0))</span>
<span class="nc" id="L95">			throw new IllegalArgumentException(&quot;contact intensity correction must be larger than 0 but is=&quot; + ciCorrection);</span>
<span class="pc bpc" id="L96" title="3 of 8 branches missed.">		if (maskUsage != null &amp;&amp; maskUsage.values().stream().anyMatch(p -&gt; p &lt; 0 || p &gt; 1))</span>
<span class="nc" id="L97">			throw new IllegalArgumentException(&quot;Mask usage probabilities must be between [0, 1]&quot;);</span>
<span class="pc bpc" id="L98" title="3 of 8 branches missed.">		if (susceptibleRf != null &amp;&amp;  (Double.isNaN(susceptibleRf) || susceptibleRf &lt; 0 || susceptibleRf &gt; 1))</span>
<span class="nc" id="L99">			throw new IllegalArgumentException(&quot;Susceptible fraction must be between 0 and 1 but is=&quot;+ susceptibleRf);</span>

<span class="fc" id="L101">		this.remainingFraction = remainingFraction;</span>
<span class="fc" id="L102">		this.ciCorrection = ciCorrection;</span>
<span class="fc" id="L103">		this.maxGroupSize = maxGroupSize;</span>
<span class="fc" id="L104">		this.reducedGroupSize = reducedGroupSize;</span>
<span class="fc" id="L105">		this.closingHours = closingHours;</span>
<span class="fc" id="L106">		this.susceptibleRf = susceptibleRf;</span>
<span class="fc" id="L107">		this.vaccinatedRf = vaccinatedRf;</span>

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (closed != null) {</span>
<span class="nc" id="L110">			this.closed = closed.stream().map(s -&gt; Id.create(s, ActivityFacility.class)).collect(Collectors.toSet());</span>
		}

		// Compute cumulative probabilities
<span class="fc bfc" id="L114" title="All 4 branches covered.">		if (maskUsage != null &amp;&amp; !maskUsage.isEmpty()) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">			if (maskUsage.containsKey(FaceMask.NONE))</span>
<span class="nc" id="L116">				throw new IllegalArgumentException(&quot;Mask usage for NONE must not be given&quot;);</span>

			// stream must be sorted or the order is undefined, which can result in different sums
<span class="fc" id="L119">			double total = maskUsage.values().stream().sorted().mapToDouble(Double::doubleValue).sum();</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">			if (total &gt; 1) throw new IllegalArgumentException(&quot;Sum of mask usage rates must be &lt; 1&quot;);</span>

<span class="fc" id="L122">			double sum = 1 - total;</span>
<span class="fc" id="L123">			this.maskUsage.put(FaceMask.NONE, sum);</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">			for (FaceMask m : FaceMask.values()) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">				if (maskUsage.containsKey(m)) {</span>
<span class="fc" id="L127">					sum += maskUsage.get(m);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">					if (Double.isNaN(sum))</span>
<span class="nc" id="L129">						throw new IllegalArgumentException(&quot;Mask usage contains NaN value!&quot;);</span>

<span class="fc" id="L131">					this.maskUsage.put(m, sum);</span>
				}
			}
		}

<span class="fc" id="L136">		this.locationBasedRf = locationBasedRf;</span>
<span class="fc" id="L137">	}</span>

	/**
	 * Create from other restriction.
	 *
	 * @param maskUsage will only be used of other is null
	 */
	Restriction(@Nullable Double remainingFraction, @Nullable Double ciCorrection, @Nullable Integer maxGroupSize, @Nullable Integer reducedGroupSize,
				@Nullable List&lt;String&gt; closed, @Nullable ClosingHours closingHours, @Nullable Map&lt;FaceMask, Double&gt; maskUsage, Map&lt;String, Double&gt; locationBasedRf,
<span class="fc" id="L146">				@Nullable Double susceptibleRf, @Nullable Double vaccinatedRf, Restriction other) {</span>
<span class="fc" id="L147">		this.remainingFraction = remainingFraction;</span>
<span class="fc" id="L148">		this.ciCorrection = ciCorrection;</span>
<span class="fc" id="L149">		this.maxGroupSize = maxGroupSize;</span>
<span class="fc" id="L150">		this.reducedGroupSize = reducedGroupSize;</span>
<span class="fc" id="L151">		this.closingHours = closingHours;</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">		this.maskUsage.putAll(other != null ? other.maskUsage : maskUsage);</span>
<span class="fc" id="L153">		this.locationBasedRf = locationBasedRf;</span>
<span class="fc" id="L154">		this.susceptibleRf = susceptibleRf;</span>
<span class="fc" id="L155">		this.vaccinatedRf = vaccinatedRf;</span>

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">		if (closed != null) {</span>
<span class="nc" id="L158">			this.closed = closed.stream().map(s -&gt; Id.create(s, ActivityFacility.class)).collect(Collectors.toSet());</span>
		}
<span class="fc" id="L160">	}</span>


	public void setLocationBasedRf(Map&lt;String, Double&gt; locationBasedRf) {
<span class="fc" id="L164">		this.locationBasedRf = locationBasedRf;</span>
<span class="fc" id="L165">	}</span>

	public Map&lt;String, Double&gt; getLocationBasedRf() {
<span class="fc" id="L168">		return this.locationBasedRf;</span>
	}



	/**
	 * Restriction that allows everything.
	 */
	public static Restriction none() {
<span class="fc" id="L177">		return new Restriction(1d, 1d, Integer.MAX_VALUE, Integer.MAX_VALUE,null,</span>
<span class="fc" id="L178">				new ClosingHours(0, 0), Map.of(), new HashMap&lt;&gt;(), 1d, 1d);</span>
	}

	/**
	 * Restriction only reducing the {@link #remainingFraction}.
	 */
	public static Restriction of(double remainingFraction) {
<span class="fc" id="L185">		return new Restriction(remainingFraction, null, null, null,null, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Restriction with remaining fraction and ci correction.
	 */
	public static Restriction of(double remainingFraction, double ciCorrection) {
<span class="fc" id="L192">		return new Restriction(remainingFraction, ciCorrection, null, null,null, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Restriction with remaining fraction, ci correction and mask usage.
	 */
	public static Restriction of(double remainingFraction, double ciCorrection, Map&lt;FaceMask, Double&gt; maskUsage) {
<span class="fc" id="L199">		return new Restriction(remainingFraction, ciCorrection, null, null,null, null, maskUsage, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Helper function for restriction with one mask compliance.
	 * See {@link #ofMask(FaceMask, double)}.
	 */
	public static Restriction of(double remainingFraction, FaceMask mask, double maskCompliance) {
<span class="nc" id="L207">		return new Restriction(remainingFraction, null, null, null,null, null, Map.of(mask, maskCompliance), new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction with one mask type and its compliance rates.
	 *
	 * @see #ofMask(Map)
	 */
	public static Restriction ofMask(FaceMask mask, double complianceRate) {
<span class="fc" id="L216">		return new Restriction(null, null, null, null,null, null, Map.of(mask, complianceRate), new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction with required masks and compliance rates. Sum has to be smaller than 1.
	 * Not defined probability goes into the {@link FaceMask#NONE}.
	 */
	public static Restriction ofMask(Map&lt;FaceMask, Double&gt; maskUsage) {
<span class="fc" id="L224">		return new Restriction(null, null, null,null, null, null, maskUsage, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction with certain facilities closed. Should not be combined with other restrictions.
	 */
	public static Restriction ofClosedFacilities(List&lt;String&gt; closed) {
<span class="nc" id="L231">		return new Restriction(null, null, null,null, closed, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction, which has only a contact intensity correction set.
	 */
	public static Restriction ofCiCorrection(double ciCorrection) {
<span class="fc" id="L238">		return new Restriction(null, ciCorrection, null,null, null, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction with limited maximum group size of activities.
	 */
	public static Restriction ofGroupSize(int maxGroupSize) {
<span class="fc" id="L245">		return new Restriction(null, null, maxGroupSize, null,null, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Restriction that reduces group sizes of activities.
	 * Unlike {@link #ofGroupSize(int)} activities above {@code maxGroupSize} are not closed completely, but have reduced participation.
	 *
	 * @param maxGroupSize maximum allowed group size
	 */
	public static Restriction ofReducedGroupSize(int maxGroupSize) {
<span class="fc" id="L255">		return new Restriction(null, null, null, maxGroupSize, null, null, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Creates a restriction for activity to be closed during certain hours.
	 * If {@code fromHour} is larger than {@code toHour} it is assumed that the closing hour is over midnight.
	 *
	 * @param fromHour hour of the day when activity will close
	 * @param toHour   hour of the day when activity will open again.
	 */
	public static Restriction ofClosingHours(int fromHour, int toHour) {

<span class="fc" id="L267">		ClosingHours closed = asClosingHours(List.of(fromHour * 3600, toHour * 3600));</span>

<span class="fc" id="L269">		return new Restriction(null, null, null, null,null, closed, null, new HashMap&lt;&gt;(), null, null);</span>
	}

	/**
	 * Restrict percentage of activities for unvaccinated and susceptible persons.
	 *
	 * @param remainingFraction remaining fraction of unvaccinated persons, i.e. 0 bans this activity for all unvaccinated persons.
	 */
	@Beta
	public static Restriction ofSusceptibleRf(double remainingFraction) {
<span class="fc" id="L279">		return new Restriction(null, null, null, null, null, null, null, new HashMap&lt;&gt;(), remainingFraction, null);</span>
	}

	/**
	 * Restrict percentage of activities for vaccinated persons.
	 *
	 * @param remainingFraction remaining fraction for vaccinated persons.
	 */
	@Beta
	public static Restriction ofVaccinatedRf(double remainingFraction) {
<span class="nc" id="L289">		return new Restriction(null, null, null, null, null, null, null, new HashMap&lt;&gt;(), null, remainingFraction);</span>
	}

	public static Restriction ofLocationBasedRf(Map&lt;String, Double&gt; locationBasedRf) {
<span class="fc" id="L293">		return new Restriction(null, null, null, null, null, null, null, locationBasedRf, null, null);</span>

	}

	/**
	 * Creates a restriction from a config entry.
	 */
	public static Restriction fromConfig(Config config) {
		// Could be integer or double
<span class="fc" id="L302">		Map&lt;String, Number&gt; nameMap = (Map&lt;String, Number&gt;) config.getValue(&quot;masks&quot;).unwrapped();</span>

<span class="fc" id="L304">		Map&lt;FaceMask, Double&gt; enumMap = new EnumMap&lt;&gt;(FaceMask.class);</span>

<span class="fc" id="L306">		Map&lt;String, Double&gt; locationBasedRf = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">		if (!config.getIsNull(&quot;locationBasedRf&quot;)) {</span>
<span class="fc" id="L309">			Map&lt;String, Double&gt; valueFromConfig = (Map&lt;String, Double&gt;) config.getValue(&quot;locationBasedRf&quot;).unwrapped();</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">			if (valueFromConfig != null) {</span>
<span class="fc" id="L311">				locationBasedRf = valueFromConfig;</span>
			}
		}


<span class="pc bpc" id="L316" title="1 of 2 branches missed.">		if (nameMap != null)</span>
<span class="fc" id="L317">			nameMap.forEach((k, v) -&gt; enumMap.put(FaceMask.valueOf(k), v.doubleValue()));</span>

<span class="fc" id="L319">		return new Restriction(</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">				config.getIsNull(&quot;fraction&quot;) ? null : config.getDouble(&quot;fraction&quot;),</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">				config.getIsNull(&quot;ciCorrection&quot;) ? null : config.getDouble(&quot;ciCorrection&quot;),</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">				config.getIsNull(&quot;maxGroupSize&quot;) ? null : config.getInt(&quot;maxGroupSize&quot;),</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">				!config.hasPath(&quot;reducedGroupSize&quot;) || config.getIsNull(&quot;reducedGroupSize&quot;) ? null : config.getInt(&quot;reducedGroupSize&quot;),</span>
<span class="pc bpc" id="L324" title="3 of 4 branches missed.">				!config.hasPath(&quot;closed&quot;) || config.getIsNull(&quot;closed&quot;) ? null : config.getStringList(&quot;closed&quot;),</span>
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">				!config.hasPath(&quot;closingHours&quot;) || config.getIsNull(&quot;closingHours&quot;) ? null : asClosingHours(config.getIntList(&quot;closingHours&quot;)),</span>
				enumMap, locationBasedRf,
<span class="fc bfc" id="L327" title="All 2 branches covered.">				config.getIsNull(&quot;susceptibleRf&quot;) ? null : config.getDouble(&quot;susceptibleRf&quot;),</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">				config.getIsNull(&quot;vaccinatedRf&quot;) ? null : config.getDouble(&quot;vaccinatedRf&quot;),</span>
				null
		);
	}

	/**
	 * Convert list of ints to closing hour instances.
	 */
	private static ClosingHours asClosingHours(List&lt;Integer&gt; closingHours) {

<span class="fc bfc" id="L338" title="All 2 branches covered.">		if (closingHours == null)</span>
<span class="fc" id="L339">			return null;</span>

<span class="fc" id="L341">		return new ClosingHours(closingHours.get(0), closingHours.get(1));</span>
	}

	/**
	 * Creates a copy of a restriction.
	 */
	static Restriction clone(Restriction restriction) {
<span class="fc" id="L348">		return new Restriction(restriction.remainingFraction, restriction.ciCorrection, restriction.maxGroupSize, restriction.reducedGroupSize,</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">				restriction.closed == null ? null : restriction.closed.stream().map(Objects::toString).collect(Collectors.toList()),</span>
				restriction.closingHours,
				null,
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">				restriction.locationBasedRf == null ? new HashMap&lt;&gt;() : restriction.locationBasedRf,</span>
				restriction.susceptibleRf,
				restriction.vaccinatedRf,
				restriction);
	}

	/**
	 * Determines / Randomly draws which mask a persons wears while this restriction is in place.
	 */
	public FaceMask determineMask(SplittableRandom rnd) {

<span class="fc bfc" id="L363" title="All 2 branches covered.">		if (maskUsage.isEmpty()) return FaceMask.NONE;</span>

<span class="fc" id="L365">		double p = Double.NaN;</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">		for (Map.Entry&lt;FaceMask, Double&gt; e : maskUsage.entrySet()) {</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">			if (e.getValue() == 1d) return e.getKey();</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">			else if (Double.isNaN(p))</span>
<span class="fc" id="L370">				p =rnd.nextDouble();</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">			if (p &lt; e.getValue())</span>
<span class="fc" id="L373">				return e.getKey();</span>

<span class="fc" id="L375">		}</span>

<span class="nc" id="L377">		throw new IllegalStateException(&quot;Could not determine mask. Probabilities are likely wrong.&quot;);</span>
	}

	/**
	 * Check whether one time falls into a closing hour.
	 *
	 * @param sod      timestamp as seconds of day
	 * @param adjustFrom when true result time is shifted to be later, otherwise shifted to start of closing hour
	 * @return adjusted time, unchanged when not in closing hour. Otherwise moved to closing hours
	 */
	double calculateOverlap(double sod, boolean adjustFrom) {
		// seconds of day
<span class="fc" id="L389">		ClosingHours ch = closingHours;</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">		if (adjustFrom) {</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">			if (ch.overnight)</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">				return sod &gt;= ch.from ? ch.length - (sod - ch.from) : ch.length -  (sod + 86400 - ch.from);</span>

<span class="fc" id="L395">			return ch.length - (sod - ch.from);</span>
		} else {
<span class="fc bfc" id="L397" title="All 2 branches covered.">			if (ch.overnight)</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">				return sod &lt;= ch.to ? ch.length - (ch.to - sod) : sod - ch.from;</span>


<span class="fc" id="L401">			return ch.length - (ch.to - sod);</span>
		}

	}

	/**
	 * Calculate how many seconds are overlapped by the closing hour, given a time interval.
	 *
	 * @return overlap or 0 if the time interval is inside the closing.
	 */
	public double overlapWithClosingHour(double from, double to) {

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">		if (closingHours == null)</span>
<span class="nc" id="L414">			return 0;</span>

		// closing of 0-24 needs to be handled separately, as overlap would be infinite
<span class="fc bfc" id="L417" title="All 2 branches covered.">		if (closingHours.length &gt;= 86400)</span>
<span class="fc" id="L418">			return Integer.MAX_VALUE;</span>

<span class="fc" id="L420">		double fSod = from % 86400;</span>
<span class="fc" id="L421">		double tSod = to % 86400;</span>
<span class="fc" id="L422">		ClosingHours ch = closingHours;</span>

<span class="fc" id="L424">		boolean containsFrom = ch.contains(fSod);</span>
<span class="fc" id="L425">		boolean containsTo = ch.contains(tSod);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">		boolean actOvernight = tSod &lt; fSod;</span>

<span class="fc bfc" id="L428" title="All 4 branches covered.">		if (containsFrom &amp;&amp; containsTo) {</span>
			// whole time nullified
<span class="fc" id="L430">			return to - from;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">		} else if (containsFrom) {</span>
<span class="fc" id="L432">			return calculateOverlap(fSod, true);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">		} else if (containsTo) {</span>
<span class="fc" id="L434">			return calculateOverlap(tSod, false);</span>

<span class="fc bfc" id="L436" title="All 4 branches covered.">		} else if (ch.includedIn(fSod, tSod) &amp;&amp; (ch.overnight == actOvernight)) {</span>
			// reduce by time of closing hour length
<span class="fc" id="L438">			return ch.length;</span>
<span class="pc bpc" id="L439" title="1 of 6 branches missed.">		} else if (actOvernight &amp;&amp; !ch.overnight &amp;&amp; tSod &gt;= ch.to) {</span>
			// also covered completely
<span class="fc" id="L441">			return ch.length;</span>
		}

<span class="fc" id="L444">		return 0;</span>
	}

	/**
	 * This method is also used to write the restriction to csv.
	 */
	@Override
	public String toString() {
<span class="fc" id="L452">		return String.format(Locale.ENGLISH, &quot;%.2f_%.2f_%s&quot;, remainingFraction, ciCorrection, maskUsage);</span>
	}

	/**
	 * Set restriction values from other restriction update.
	 */
	void update(Restriction r) {
		// All values may be optional and are only set if present
<span class="fc bfc" id="L460" title="All 2 branches covered.">		if (r.getRemainingFraction() != null)</span>
<span class="fc" id="L461">			remainingFraction = r.getRemainingFraction();</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">		if (r.getCiCorrection() != null)</span>
<span class="fc" id="L464">			ciCorrection = r.getCiCorrection();</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (r.getMaxGroupSize() != null)</span>
<span class="fc" id="L467">			maxGroupSize = r.getMaxGroupSize();</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">		if (r.getReducedGroupSize() != null)</span>
<span class="fc" id="L470">			reducedGroupSize = r.getReducedGroupSize();</span>

<span class="fc bfc" id="L472" title="All 2 branches covered.">		if (r.getSusceptibleRf() != null)</span>
<span class="fc" id="L473">			susceptibleRf = r.getSusceptibleRf();</span>

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">		if (r.getVaccinatedRf() != null)</span>
<span class="nc" id="L476">			vaccinatedRf = r.getVaccinatedRf();</span>

<span class="pc bpc" id="L478" title="1 of 2 branches missed.">		if (r.closed != null)</span>
<span class="nc" id="L479">			closed = r.closed;</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">		if (r.closingHours != null)</span>
<span class="fc" id="L482">			closingHours = r.closingHours;</span>

<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (!r.maskUsage.isEmpty()) {</span>
<span class="fc" id="L485">			maskUsage.clear();</span>
<span class="fc" id="L486">			maskUsage.putAll(r.maskUsage);</span>
		}
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">		if (r.locationBasedRf !=null &amp;&amp; !r.locationBasedRf.isEmpty()) {</span>
<span class="fc" id="L489">			locationBasedRf = new HashMap&lt;&gt;();</span>
<span class="fc" id="L490">			locationBasedRf.putAll(r.locationBasedRf);</span>

		}
<span class="fc" id="L493">	}</span>

	/**
	 * Merges another restrictions into this one. Will fail if any attribute would be overwritten.
	 *
	 * localRf: if new restriction has a Rf, the localRf will NOT be included in merged result; reason: to aid users who
	 * manually enter restrictions, but forget to clear the localRf.
	 *
	 * @see #asMap()
	 */
	void merge(Map&lt;String, Object&gt; restriction) {

<span class="fc" id="L505">		Double otherRf = (Double) restriction.get(&quot;fraction&quot;);</span>
<span class="fc" id="L506">		Double otherE = (Double) restriction.get(&quot;ciCorrection&quot;);</span>
<span class="fc" id="L507">		Integer otherGroup = (Integer) restriction.get(&quot;maxGroupSize&quot;);</span>
<span class="fc" id="L508">		Integer otherReduced = (Integer) restriction.get(&quot;reducedGroupSize&quot;);</span>
<span class="fc" id="L509">		Double otherSRf = (Double) restriction.get(&quot;susceptibleRf&quot;);</span>
<span class="fc" id="L510">		Double otherVRf = (Double) restriction.get(&quot;vaccinatedRf&quot;);</span>
<span class="fc" id="L511">		ClosingHours otherClosingH = asClosingHours((List&lt;Integer&gt;) restriction.get(&quot;closingHours&quot;));</span>

<span class="fc" id="L513">		Map&lt;FaceMask, Double&gt; otherMasks = new EnumMap&lt;&gt;(FaceMask.class);</span>
<span class="fc" id="L514">		((Map&lt;String, Double&gt;) restriction.get(&quot;masks&quot;))</span>
<span class="fc" id="L515">				.forEach((k, v) -&gt; otherMasks.put(FaceMask.valueOf(k), v));</span>

<span class="fc" id="L517">		Map&lt;String, Double&gt; otherLocationBasedRf = new HashMap&lt;&gt;();</span>
<span class="fc" id="L518">		((Map&lt;String, Double&gt;) restriction.get(&quot;locationBasedRf&quot;)).forEach(((key, value) -&gt; otherLocationBasedRf.put(key, value)));</span>

		// if new and old Restriction have equal Rfs: warn
<span class="pc bpc" id="L521" title="1 of 6 branches missed.">		if (remainingFraction != null &amp;&amp; otherRf != null &amp;&amp; !remainingFraction.equals(otherRf)){</span>
<span class="fc" id="L522">			log.warn(&quot;Duplicated remainingFraction &quot; + remainingFraction + &quot; and &quot; + otherRf);</span>
		}
		// if new Restriction doesn't have value for Rf:
		// 1) keep old value for Rf
		// 2) check whether new Restriction has localRf, and if not, then use localRf from old Restriction
<span class="fc bfc" id="L527" title="All 2 branches covered.">		else if (remainingFraction == null){</span>
<span class="fc" id="L528">			remainingFraction = otherRf;</span>

<span class="pc bpc" id="L530" title="1 of 6 branches missed.">			if (!locationBasedRf.isEmpty() &amp;&amp; !otherLocationBasedRf.isEmpty() &amp;&amp; !locationBasedRf.equals(otherLocationBasedRf)) {</span>
<span class="nc" id="L531">				log.warn(&quot;Duplicated locationBasedRf usage; existing value=&quot; + locationBasedRf + &quot;; new value=&quot; + otherLocationBasedRf + &quot;; keeping existing value.&quot;);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">			} else if (locationBasedRf.isEmpty()) {</span>
<span class="fc" id="L533">				locationBasedRf.putAll(otherLocationBasedRf);</span>
			}
		} else {
<span class="pc bpc" id="L536" title="2 of 4 branches missed.">			if ((locationBasedRf == null || locationBasedRf.isEmpty())</span>
<span class="pc bpc" id="L537" title="1 of 4 branches missed.">					&amp;&amp; (!otherLocationBasedRf.isEmpty() || otherLocationBasedRf != null)) {</span>

<span class="fc" id="L539">				log.warn(&quot;localRf removed during merge, as new remainingFraction was provided&quot;);</span>
			}
		}


<span class="pc bpc" id="L544" title="3 of 6 branches missed.">		if (ciCorrection != null &amp;&amp; otherE != null &amp;&amp; !ciCorrection.equals(otherE))</span>
<span class="nc" id="L545">			log.warn(&quot;Duplicated ci correction &quot; + ciCorrection + &quot; and &quot; + otherE);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">		else if (ciCorrection == null)</span>
<span class="fc" id="L547">			ciCorrection = otherE;</span>

<span class="pc bpc" id="L549" title="3 of 6 branches missed.">		if (maxGroupSize != null &amp;&amp; otherGroup != null &amp;&amp; !maxGroupSize.equals(otherGroup))</span>
<span class="nc" id="L550">			log.warn(&quot;Duplicated max group size &quot; + maxGroupSize + &quot; and &quot; + otherGroup);</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">		else if (maxGroupSize == null)</span>
<span class="fc" id="L552">			maxGroupSize = otherGroup;</span>

<span class="pc bpc" id="L554" title="3 of 6 branches missed.">		if (reducedGroupSize != null &amp;&amp; otherReduced != null &amp;&amp; !reducedGroupSize.equals(otherReduced))</span>
<span class="nc" id="L555">			log.warn(&quot;Duplicated reduced group size &quot; + reducedGroupSize + &quot; and &quot; + otherReduced);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">		else if (reducedGroupSize == null)</span>
<span class="fc" id="L557">			reducedGroupSize = otherReduced;</span>

<span class="pc bpc" id="L559" title="1 of 6 branches missed.">		if (closingHours != null &amp;&amp; otherClosingH != null &amp;&amp; !closingHours.equals(otherClosingH))</span>
<span class="fc" id="L560">			log.warn(&quot;Duplicated max closing hours &quot; + closingHours + &quot; and &quot; + otherClosingH);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">		else if (closingHours == null)</span>
<span class="fc" id="L562">			closingHours = otherClosingH;</span>

<span class="pc bpc" id="L564" title="5 of 6 branches missed.">		if (susceptibleRf != null &amp;&amp; otherSRf != null &amp;&amp; !susceptibleRf.equals(otherSRf))</span>
<span class="nc" id="L565">			log.warn(&quot;Duplicated susceptible fraction &quot; + susceptibleRf + &quot; and &quot; + otherSRf);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">		else if (susceptibleRf == null)</span>
<span class="fc" id="L567">			susceptibleRf = otherSRf;</span>

<span class="pc bpc" id="L569" title="5 of 6 branches missed.">		if (vaccinatedRf != null &amp;&amp; otherVRf != null &amp;&amp; !vaccinatedRf.equals(otherVRf))</span>
<span class="nc" id="L570">			log.warn(&quot;Duplicated vaccinated fraction &quot; + vaccinatedRf + &quot; and &quot; + otherVRf);</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">		else if (vaccinatedRf == null)</span>
<span class="fc" id="L572">			vaccinatedRf = otherVRf;</span>

<span class="pc bpc" id="L574" title="3 of 6 branches missed.">		if (!maskUsage.isEmpty() &amp;&amp; !otherMasks.isEmpty() &amp;&amp; !maskUsage.equals(otherMasks)) {</span>
<span class="nc" id="L575">			log.warn(&quot;Duplicated mask usage; existing value=&quot; + maskUsage + &quot;; new value=&quot; + otherMasks + &quot;; keeping existing value.&quot;);</span>
<span class="nc" id="L576">			log.warn(&quot;(full new restriction=&quot; + restriction + &quot;)&quot;);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">		} else if (maskUsage.isEmpty())</span>
<span class="fc" id="L578">			maskUsage.putAll(otherMasks);</span>

<span class="fc" id="L580">	}</span>

	boolean isExtrapolate() {
<span class="fc" id="L583">		return extrapolate;</span>
	}

	void setExtrapolate(boolean extrapolate) {
<span class="fc" id="L587">		this.extrapolate = extrapolate;</span>
<span class="fc" id="L588">	}</span>

	public Double getRemainingFraction() {
<span class="fc" id="L591">		return remainingFraction;</span>
	}

	void setRemainingFraction(double remainingFraction) {
<span class="fc" id="L595">		this.remainingFraction = remainingFraction;</span>
<span class="fc" id="L596">	}</span>

	public Double getCiCorrection() {
<span class="fc" id="L599">		return ciCorrection;</span>
	}

	public boolean isClosed(Id&lt;?&gt; containerId) {
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">		if (closed == null)</span>
<span class="fc" id="L604">			return false;</span>

<span class="nc" id="L606">		return closed.contains(containerId);</span>
	}

	@Nullable
	ClosingHours getClosingHours() {
<span class="fc" id="L611">		return closingHours;</span>
	}

	/**
	 * Whether closing hours are set.
	 */
	public boolean hasClosingHours() {
<span class="fc bfc" id="L618" title="All 4 branches covered.">		return closingHours != null &amp;&amp; closingHours.to != closingHours.from;</span>
	}

	@Nullable
	public Integer getMaxGroupSize() {
<span class="fc" id="L623">		return maxGroupSize;</span>
	}

	@Nullable
	public Integer getReducedGroupSize() {
<span class="fc" id="L628">		return reducedGroupSize;</span>
	}

	Map&lt;FaceMask, Double&gt; getMaskUsage() {
<span class="fc" id="L632">		return maskUsage;</span>
	}

	@Nullable
	public Double getSusceptibleRf() {
<span class="fc" id="L637">		return susceptibleRf;</span>
	}

	@Nullable
	public Double getVaccinatedRf() {
<span class="fc" id="L642">		return vaccinatedRf;</span>
	}

	/**
	 * Attributes of this restriction as map.
	 */
	public Map&lt;String, Object&gt; asMap() {
<span class="fc" id="L649">		Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L650">		map.put(&quot;fraction&quot;, remainingFraction);</span>
<span class="fc" id="L651">		map.put(&quot;ciCorrection&quot;, ciCorrection);</span>
<span class="fc" id="L652">		map.put(&quot;maxGroupSize&quot;, maxGroupSize);</span>
<span class="fc" id="L653">		map.put(&quot;reducedGroupSize&quot;, reducedGroupSize);</span>

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">		if (closed != null)</span>
<span class="nc" id="L656">			map.put(&quot;closed&quot;, closed.stream().map(Object::toString).collect(Collectors.toList()));</span>

		// Must be converted to map with strings
<span class="fc" id="L659">		Map&lt;String, Double&gt; nameMap = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L660">		maskUsage.forEach((k, v) -&gt; nameMap.put(k.name(), v));</span>
<span class="fc" id="L661">		map.put(&quot;masks&quot;, nameMap);</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">		if (closingHours != null) {</span>
<span class="fc" id="L664">			map.put(&quot;closingHours&quot;, List.of(closingHours.from, closingHours.to));</span>
		}

<span class="fc" id="L667">		map.put(&quot;locationBasedRf&quot;, locationBasedRf);</span>
<span class="fc" id="L668">		map.put(&quot;susceptibleRf&quot;, susceptibleRf);</span>
<span class="fc" id="L669">		map.put(&quot;vaccinatedRf&quot;, vaccinatedRf);</span>

<span class="fc" id="L671">		return map;</span>
	}

	/**
	 * Hours when an activity is closed.
	 */
	public static final class ClosingHours {

		/**
		 * Starting second when activity is closed (exclusive)
		 */
		public final int from;

		/**
		 * Seconds until when activity is still closed.
		 */
		public final int to;

		/**
		 * Closed overnight.
		 */
		public final boolean overnight;

		/**
		 * Length of closing hours.
		 */
		public final int length;

<span class="fc" id="L699">		ClosingHours(int from, int to) {</span>
<span class="fc" id="L700">			this.from = from;</span>
<span class="fc" id="L701">			this.to = to;</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">			this.overnight = from &gt; to;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">			this.length = overnight ? (86400 - from) + to : to - from;</span>
<span class="fc" id="L704">		}</span>

		/**
		 * Check whether timestamp is contained in the closing hours.
		 */
		public boolean contains(double sod) {
<span class="fc bfc" id="L710" title="All 2 branches covered.">			if (overnight) {</span>
<span class="fc bfc" id="L711" title="All 4 branches covered.">				return sod &gt;= from || sod &lt;= to;</span>
			} else
<span class="fc bfc" id="L713" title="All 4 branches covered.">				return sod &gt;= from &amp;&amp; sod &lt;= to;</span>
		}

		/**
		 * Closing hour is completely included in this interval (as seconds of day).
		 */
		public boolean includedIn(double fSod, double tSod) {
<span class="pc bpc" id="L720" title="1 of 4 branches missed.">			return fSod &lt; from &amp;&amp; tSod &gt; to;</span>
		}

		@Override
		public boolean equals(Object o) {
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">			if (this == o) return true;</span>
<span class="pc bpc" id="L726" title="2 of 4 branches missed.">			if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L727">			ClosingHours that = (ClosingHours) o;</span>
<span class="pc bpc" id="L728" title="1 of 4 branches missed.">			return from == that.from &amp;&amp;</span>
					to == that.to;
		}

		@Override
		public int hashCode() {
<span class="nc" id="L734">			return Objects.hash(from, to);</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L739">			return &quot;ClosingHours{&quot; +</span>
					&quot;from=&quot; + from +
					&quot;, to=&quot; + to +
					'}';
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>