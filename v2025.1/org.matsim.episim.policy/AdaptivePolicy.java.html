<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AdaptivePolicy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MATSim Episim</a> &gt; <a href="index.source.html" class="el_package">org.matsim.episim.policy</a> &gt; <span class="el_source">AdaptivePolicy.java</span></div><h1>AdaptivePolicy.java</h1><pre class="source lang-java linenums">/*-
 * #%L
 * MATSim Episim
 * %%
 * Copyright (C) 2020 matsim-org
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 * #L%
 */
package org.matsim.episim.policy;

import com.google.common.collect.ImmutableMap;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigValue;
import it.unimi.dsi.fastutil.objects.*;
import org.matsim.episim.EpisimReporting;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This policy enforces restrictions based on the number of available intensive care beds
 * and the number of persons that are in critical health state.
 */
public class AdaptivePolicy extends ShutdownPolicy {

	/**
	 * Amount of days incidence has to stay below the trigger to lift restrictions.
	 */
	private static final int INTERVAL_DAY = 14;

	/**
	 * Incidences triggers for configured activities.
	 */
	private final Config incidenceTriggers;

	/**
	 * Policy applied at the start.
	 */
	private final Config initialPolicy;

	/**
	 * Policy when shutdown is in effect.
	 */
	private final Config restrictedPolicy;

	/**
	 * Policy when everything is open.
	 */
	private final Config openPolicy;

	/**
	 * Store incidence for each day.
	 */
<span class="fc" id="L69">	private final Object2DoubleSortedMap&lt;LocalDate&gt; cumCases = new Object2DoubleAVLTreeMap&lt;&gt;();</span>

	/**
	 * Whether currently in lockdown.
	 */
<span class="fc" id="L74">	private final Object2BooleanMap&lt;String&gt; inLockdown = new Object2BooleanOpenHashMap&lt;&gt;();</span>

	/**
	 * Constructor from config.
	 */
	public AdaptivePolicy(Config config) {
<span class="fc" id="L80">		super(config);</span>
<span class="fc" id="L81">		incidenceTriggers = config.getConfig(&quot;incidences&quot;);</span>
<span class="fc" id="L82">		restrictedPolicy = config.getConfig(&quot;restricted-policy&quot;);</span>
<span class="fc" id="L83">		openPolicy = config.getConfig(&quot;open-policy&quot;);</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">		initialPolicy = config.hasPath(&quot;init-policy&quot;) ? config.getConfig(&quot;init-policy&quot;) : null;</span>
<span class="fc" id="L85">	}</span>

	/**
	 * Create a config builder for {@link AdaptivePolicy}.
	 */
	public static ConfigBuilder config() {
<span class="fc" id="L91">		return new ConfigBuilder();</span>
	}

	@Override
	public void init(LocalDate start, ImmutableMap&lt;String, Restriction&gt; restrictions) {
<span class="pc bpc" id="L96" title="2 of 4 branches missed.">		if (initialPolicy != null &amp;&amp; !initialPolicy.isEmpty()) {</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">			for (Map.Entry&lt;String, Restriction&gt; e : restrictions.entrySet()) {</span>
<span class="fc" id="L99">				updateRestrictions(start, initialPolicy, e.getKey(), e.getValue());</span>
<span class="fc" id="L100">			}</span>
		}
<span class="fc" id="L102">	}</span>

	@Override
	public void restore(LocalDate start, ImmutableMap&lt;String, Restriction&gt; restrictions) {
<span class="nc" id="L106">		init(start, restrictions);</span>
<span class="nc" id="L107">	}</span>

	@Override
	public void updateRestrictions(EpisimReporting.InfectionReport report, ImmutableMap&lt;String, Restriction&gt; restrictions) {

<span class="fc" id="L112">		LocalDate date = LocalDate.parse(report.date);</span>

<span class="fc" id="L114">		calculateCases(report);</span>
<span class="fc" id="L115">		Object2DoubleSortedMap&lt;LocalDate&gt; cases = cumCases.tailMap(date.minus(INTERVAL_DAY + 6, ChronoUnit.DAYS));</span>

<span class="fc" id="L117">		Object2DoubleSortedMap&lt;LocalDate&gt; incidence = new Object2DoubleAVLTreeMap&lt;&gt;();</span>

<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		for (Object2DoubleMap.Entry&lt;LocalDate&gt; from : cases.object2DoubleEntrySet()) {</span>
<span class="fc" id="L120">			LocalDate until = from.getKey().plusDays(7);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (cases.containsKey(until)) {</span>
<span class="fc" id="L122">				incidence.put(until, cases.getDouble(until) - cases.getDouble(from.getKey()));</span>
			} else
				// if until was not contained, the next ones will not be either
				break;
<span class="fc" id="L126">		}</span>

		// for first 7 days, restrictions will stay the same
<span class="fc bfc" id="L129" title="All 2 branches covered.">		if (incidence.isEmpty())</span>
<span class="fc" id="L130">			return;</span>

		// TODO: use first incidence to decide whether in lockdown or not

<span class="fc bfc" id="L134" title="All 2 branches covered.">		for (Map.Entry&lt;String, ConfigValue&gt; e : incidenceTriggers.entrySet()) {</span>

<span class="fc" id="L136">			String act = e.getKey();</span>
<span class="fc" id="L137">			List&lt;Double&gt; trigger = (List&lt;Double&gt;) e.getValue().unwrapped();</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">			if (inLockdown.getBoolean(act)) {</span>
<span class="fc bfc" id="L140" title="All 4 branches covered.">				if (incidence.values().stream().allMatch(inc -&gt; inc &lt;= trigger.get(0))) {</span>
<span class="fc" id="L141">					updateRestrictions(date, openPolicy, act, restrictions.get(act));</span>
<span class="fc" id="L142">					inLockdown.put(act, false);</span>
				}

			} else {
<span class="fc bfc" id="L146" title="All 2 branches covered.">				if (incidence.getDouble(incidence.lastKey()) &gt;= trigger.get(1)) {</span>
<span class="fc" id="L147">					updateRestrictions(date, restrictedPolicy, act, restrictions.get(act));</span>
<span class="fc" id="L148">					inLockdown.put(act, true);</span>
				}
			}
<span class="fc" id="L151">		}</span>
<span class="fc" id="L152">	}</span>

	/**
	 * Calculate incidence depending
	 */
	private void calculateCases(EpisimReporting.InfectionReport report) {
<span class="fc" id="L158">		double cases = report.nShowingSymptomsCumulative * (100_000d / report.nTotal());</span>
<span class="fc" id="L159">		this.cumCases.put(LocalDate.parse(report.date), cases);</span>
<span class="fc" id="L160">	}</span>

	private void updateRestrictions(LocalDate start, Config policy, String act, Restriction restriction) {

		// activity name
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (!policy.hasPath(act))</span>
<span class="fc" id="L166">			return;</span>

<span class="fc" id="L168">		Config actConfig = policy.getConfig(act);</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">		for (Map.Entry&lt;String, ConfigValue&gt; days : actConfig.root().entrySet()) {</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">			if (days.getKey().startsWith(&quot;day&quot;)) continue;</span>

<span class="fc" id="L173">			LocalDate date = LocalDate.parse(days.getKey());</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">			if (date.isBefore(start)) {</span>
<span class="fc" id="L175">				Restriction r = Restriction.fromConfig(actConfig.getConfig(days.getKey()));</span>
<span class="fc" id="L176">				restriction.update(r);</span>
			}
<span class="fc" id="L178">		}</span>
<span class="fc" id="L179">	}</span>

	/**
	 * Config builder for {@link AdaptivePolicy}.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static final class ConfigBuilder extends ShutdownPolicy.ConfigBuilder&lt;Object&gt; {

		/**
		 * Use {@link #AdaptivePolicy#config()}.
		 */
<span class="fc" id="L190">		private ConfigBuilder() {</span>
<span class="fc" id="L191">			params.put(&quot;start-in-lockdown&quot;, false);</span>
<span class="fc" id="L192">		}</span>

		/**
		 * Define trigger for weekly incidence and individual activities.
		 */
		public ConfigBuilder incidenceTrigger(double openAt, double restrictAt, String... activities) {

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">			if (restrictAt &lt; openAt)</span>
<span class="nc" id="L200">				throw new IllegalArgumentException(&quot;Restrict threshold must be larger than open threshold&quot;);</span>

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">			if (activities.length == 0)</span>
<span class="nc" id="L203">				throw new IllegalArgumentException(&quot;Activities can not be empty&quot;);</span>


<span class="fc" id="L206">			Map&lt;String, List&lt;Double&gt;&gt; incidences = (Map&lt;String, List&lt;Double&gt;&gt;) params.computeIfAbsent(&quot;incidences&quot;, (k) -&gt; new HashMap&lt;&gt;());</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">			for (String act : activities) {</span>
<span class="fc" id="L208">				incidences.put(act, List.of(openAt, restrictAt));</span>
			}

<span class="fc" id="L211">			return this;</span>
		}

		/**
		 * Set the initial policy that is always applied.
		 */
		public ConfigBuilder initialPolicy(FixedPolicy.ConfigBuilder policy) {
<span class="fc" id="L218">			params.put(&quot;init-policy&quot;, policy.params);</span>
<span class="fc" id="L219">			return this;</span>
		}

		/**
		 * See {@link AdaptivePolicy#openPolicy}.
		 */
		public ConfigBuilder openPolicy(FixedPolicy.ConfigBuilder policy) {
<span class="fc" id="L226">			params.put(&quot;open-policy&quot;, policy.params);</span>
<span class="fc" id="L227">			return this;</span>
		}

		/**
		 * See {@link AdaptivePolicy#restrictedPolicy}.
		 */
		public ConfigBuilder restrictedPolicy(FixedPolicy.ConfigBuilder policy) {
<span class="fc" id="L234">			params.put(&quot;restricted-policy&quot;, policy.params);</span>
<span class="fc" id="L235">			return this;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>